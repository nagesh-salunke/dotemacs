#+TITLE: Nagesh Salunke's Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle yes

* Introduction
** About the file
And, I start using emacs !
Initially when I tried using emacs, It became a habit to use it.
Sometime all I do is YakShave my init file.
To make the yakshaving better organized,
I am moving all config that I liked, copied or found from blogs into this org file.
Sometime I also update this file as per my needs.

This file is combination of my reading others configuration, hours invested in watching youtube video,
and my limited knowledge on emacs lisp ( still learning ).
I hope to save a lot of time from my work by using emacs and utilize that time to learn more of emacs.

** Installation
I am not sure why, but If you would like to use my configuration

=git clone https://github.com/nagesh-salunke/dotemacs ~/.emacs.d=

Keep in mind that you should remove your own ~/.emacs and your ~/.emacs.d
prior to cloning this configuration and take a backup if not done already.
The next time you launch Emacs it's going to download a good amount
of packages and configure them for you, you might see warnings and errors being
displayed as well, those are safe to ignore as long as you relaunch emacs and
see none.

** References
I read stuff, lot of stuff, lot of code and I do watch youtube videos.
When I was enlightned with the capability of emacs, I found emacs heros around.
Everywhere - On youtube, on github, on blogs, on twitter. I followed many and learning from them.
I plan to keep a list of things from where I learnt emacs over here

*** Youtube
*** Github
*** Twitter
*** Blogs

* Configuration
** Starting up

#+begin_src emacs-lisp
;; This sets up the load path so that we can override it
(add-to-list 'load-path "~/elisp")
(package-initialize)
;;; configure use package
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(setq use-package-verbose t)
(setq use-package-always-ensure t)
#+END_SRC

** Personal Details

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Nagesh Salunke"
      user-mail-address "salunkenagesh14@gmail.com"
      calendar-latitude 18.5204
      calendar-longitude 73.8567
      calendar-location-name "Pune, IN")
#+END_SRC

** Init
*** Package sources

#+BEGIN_SRC emacs-lisp
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("marmalade" . "https://marmalade-repo.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

*** Elisp directory and others

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/elisp")
(require 'use-package)
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

** General configuration
*** Backup

This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
*** History

From http://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html:
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** Emacs-server

#+BEGIN_SRC emacs-lisp
(load "server")
(unless (server-running-p) (server-start))
#+END_SRC

** Looks and more
*** Basic  - Inteface, General
**** Full screen

Start in full screen mode.
#+BEGIN_SRC emacs-lisp
(toggle-frame-fullscreen)
#+END_SRC

**** Disable startup screen and menu bar
No GUI - remove toolbar menubar

#+BEGIN_SRC emacs-lisp
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
  (when (fboundp mode) (funcall mode -1)))

(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
#+END_SRC
**** Disable bell

Bell is not good, annoying!

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

**** Highligh current line

 =hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
 Besides, it's only used for programming.
 #+BEGIN_SRC emacs-lisp
   (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
 #+END_SRC

**** Pretty symbols

Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.

#+BEGIN_SRC emacs-lisp
  (when window-system
        (use-package pretty-mode

        :config
        (global-pretty-mode t)))
#+END_SRC

**** Code Highlight
Highlight code always
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

**** Rainbow mode
Highlight color everywhere

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :diminish rainbow-mode
  :config
  (rainbow-mode t))
#+END_SRC

**** Which key mode

which-key mode - useful sometimes

#+BEGIN_SRC emacs-lisp
(which-key-mode 1)
#+END_SRC

**** Beacon - track cursor

Tracking the cursor when I move between buffers.

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :diminish beacon-mode
  :config
  (beacon-mode))

#+END_SRC

**** Ask before killing emacs
Why would someone want to close emacs ?
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

*** Theme and font
Theme - I keep changing themes.
#+BEGIN_SRC emacs-lisp
;;(load-theme 'zeno t)
#+END_SRC

Font
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :font "Menlo"
                    :height 170
                    :weight 'regular)
#+END_SRC
*** Modeline
**** Spaceline with  icons
;;#+BEGIN_SRC emacs-lisp
;;(use-package spaceline-all-the-icons :after spaceline
;;  :ensure t
;;  :load-path "~/.emacs.d/spaceline-all-the-icons.el")
;;(use-package spaceline :after powerline
;;  :ensure t
;;  :config (setq-default mode-line-format '("%e" (:eval (spaceline-ml-ati)))))
;;(spaceline-all-the-icons-theme)
;;#+END_SRC
**** fancy battery
;;#+BEGIN_SRC emacs-lisp
;;(use-package fancy-battery
;;      :ensure t
;;      :config
;;	(setq fancy-battery-show-percentage t)
;;	(setq battery-update-interval 15)
;;	(if window-system
;;          (fancy-battery-mode)
;;          (display-battery-mode)))
;;#+END_SRC
*** Buffer Management
**** ibuffer

ibuffer is good! I also like to arrange buffers in group

#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer-other-window)

;; ibuffer config
(setq ibuffer-saved-filter-groups
      (quote (("default"
	       ("dired" (mode . dired-mode))
	       ("org" (name . "^.*org$"))
	       ("web" (or (mode . web-mode) (mode . js2-mode)))
	       ("shell" (or (mode . term-mode) (mode . shell-mode)))
	       ("mu4e" (name . "\*mu4e\*"))
	       ("programming" (or
			       (mode . python-mode)
			       (mode . java-mode)
			       (mode . c++-mode)))
	       ("magit" (or
			 (mode . magit-mode)
			 (mode . magit-process-mode)
			 (mode . magit-diff-mode)
			 (mode . magit-revision-mode)
			 (mode . magit-status-mode)
			 (name . "$*magit*$")))
	       ("emacs" (or
			 (name . "^\\*scratch\\*$")
			 (name . "^\\*Messages\\*$")
			 (mode . emacs-lisp-mode)))
	       ("grep"	 (mode . grep-mode))
	       ))))
(add-hook 'ibuffer-mode-hook
	  (lambda ()
	    (ibuffer-auto-mode 1)
	    (ibuffer-switch-to-saved-filter-groups "default")))

;; Don't show filter groups if there are no buffers in that group
(setq ibuffer-show-empty-filter-groups nil)

;; Don't ask for confirmation to delete marked buffers
(setq ibuffer-expert t)

#+END_SRC

**** Killing current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
**** Kill buffers without asking for confirmation
 You  may lose progress for no reason when working.
 #+BEGIN_SRC emacs-lisp
;; (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
 #+END_SRC
**** close-all-buffers
 This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
 #+BEGIN_SRC emacs-lisp
   (defun close-all-buffers ()
     "Kill all buffers without regard for their origin."
     (interactive)
     (mapc 'kill-buffer (buffer-list)))
   (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
 #+END_SRC

*** Winner mode - window config

=winner-mode= lets you use =C-c <left>= and =C-c <right>= to switch between window configurations. This is handy when something has popped up a buffer that you want to look at briefly before returning to whatever you were working on. When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp
(use-package winner)
(winner-mode 1)
#+END_SRC

*** Change "yes or no" to "y or n"
Saving time :D
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Minor conveniences
**** Quickly edit emacs config
 I like emacs, I change my configuration often.
 I want to be able to visit my configuration easily

 Quickly edit =~/.emacs.d/config.org=
 #+BEGIN_SRC emacs-lisp
   (defun config-visit ()
     (interactive)
     (find-file "~/.emacs.d/config.org"))
   (global-set-key (kbd "C-c e") 'config-visit)
 #+END_SRC
**** Reload emacs config

Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/init.el at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/init.el")))
  (global-set-key (kbd "C-c y") 'config-reload)
#+END_SRC

*** Repeatable commands

Based on http://oremacs.com/2015/01/14/repeatable-commands/ . Modified to
accept =nil= as the first value if you don't want the keymap to run a
command by default, and to use =kbd= for the keybinding definitions.

#+BEGIN_SRC emacs-lisp
  (defun my/def-rep-command (alist)
    "Return a lambda that calls the first function of ALIST.
It sets the transient map to all functions of ALIST,
allowing you to repeat those functions as needed."
    (let ((keymap (make-sparse-keymap))
                  (func (cdar alist)))
      (mapc (lambda (x)
              (when x
                (define-key keymap (kbd (car x)) (cdr x))))
            alist)
      (lambda (arg)
        (interactive "p")
        (when func
          (funcall func arg))
        (set-transient-map keymap t))))
#+END_SRC
** Text Editor
*** Set UTF-8 encoding

#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
*** Goto place using char
#+BEGIN_SRC emacs-lisp
(require 'avy)
(global-set-key (kbd "C-;") 'avy-goto-char)
(global-set-key (kbd "C-:") 'avy-goto-char-2)
#+END_SRC

*** Anzu - show matches
 which displays current match and total matches information in the mode-line in various search modes

#+BEGIN_SRC emacs-lisp
(use-package anzu
    :diminish anzu-mode)
(global-anzu-mode +1)
(global-set-key (kbd "M-%") 'anzu-query-replace)
(global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)
#+END_SRC

*** Swiper - Easy search
Dont just search - swipe
#+BEGIN_SRC emacs-lisp
(use-package swiper)
(global-set-key (kbd "C-s") 'swiper)
(setq ivy-display-style 'fancy)
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter)
  )
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_SRC

*** Multiple cursors
Multiple cursors to edit thing faster.
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
     (("C-c m t" . mc/mark-all-like-this)
      ("C-c m m" . mc/mark-all-like-this-dwim)
      ("C-c m l" . mc/edit-lines)
      ("C-c m e" . mc/edit-ends-of-lines)
      ("C-c m a" . mc/edit-beginnings-of-lines)
      ("C-c m n" . mc/mark-next-like-this)
      ("C-c m p" . mc/mark-previous-like-this)
      ("C-c m d" . mc/mark-all-like-this-in-defun)))
#+end_src

*** Helm
Interactive completion for various things.
**** Helm config
 #+BEGIN_SRC emacs-lisp
   (use-package helm
     :diminish helm-mode
     :bind
     ("C-x C-f" . 'helm-find-files)
     ("M-x" . 'helm-M-x)
     ("C-c h g" . 'helm-google-suggest)
     ("M-y" . 'helm-show-kill-ring)
     :config
     (defun daedreth/helm-hide-minibuffer ()
       (when (with-helm-buffer helm-echo-input-in-header-line)
         (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
           (overlay-put ov 'window (selected-window))
           (overlay-put ov 'face
			(let ((bg-color (face-background 'default nil)))
                          `(:background ,bg-color :foreground ,bg-color)))
           (setq-local cursor-type nil))))
     (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
     (setq helm-autoresize-max-height 0
           helm-autoresize-min-height 30
           helm-M-x-fuzzy-match t
           helm-buffers-fuzzy-matching t
           helm-recentf-fuzzy-match t
           helm-semantic-fuzzy-match t
           helm-imenu-fuzzy-match t
	   helm-lisp-fuzzy-match t
	   helm-locate-fuzzy-match t
           helm-split-window-in-side-p nil
           helm-move-to-line-cycle-in-source nil
           helm-ff-search-library-in-sexp t
           helm-scroll-amount 8
           helm-echo-input-in-header-line t
	   helm-idle-delay 0.0
           helm-input-idle-delay 0.01
           helm-yas-display-key-on-candidate t
           helm-quick-update t
           helm-M-x-requires-pattern nil
           helm-ff-skip-boring-files t)
     :init
     (helm-mode 1))

   (require 'helm-config)
   (helm-autoresize-mode 1)

 #+END_SRC

 Remove first and second line from buffer to save space as  C-l serves the purpose.
 From : https://www.reddit.com/r/emacs/comments/3f55nm/how_to_remove_2_first_dot_files_from_helmfindfiles/

 #+BEGIN_SRC emacs-lisp
 (advice-add 'helm-ff-filter-candidate-one-by-one
         :around (lambda (fcn file)
                   (unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
                     (funcall fcn file))))
 #+END_SRC
*** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish flycheck-mode
  :config
  (add-hook 'after-init-hook 'global-flycheck-mode))
#+END_SRC

*** Ido
#+BEGIN_SRC emacs-lisp
(use-package ido
  :defer t
  :init (progn (ido-mode 1)
               (ido-everywhere 1))
  :config
  (progn
    (setq ido-case-fold t)
    (setq ido-everywhere t)
    (setq ido-enable-prefix nil)
    (setq ido-enable-flex-matching t)
    (setq ido-create-new-buffer 'always)
    (setq ido-max-prospects 10)
    (setq ido-use-faces nil)))
#+END_SRC
*** Kill word

Kills word your cursor is on.
#+BEGIN_SRC emacs-lisp
  (defun my/kill-inner-word ()
    "Kills the entire word your cursor in"
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'my/kill-inner-word)
#+END_SRC

*** Hungry delete
Deletes words, lines with all whitespaces, hungry delete
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :diminish hungry-delete-mode
  :config
  (global-hungry-delete-mode))
#+END_SRC

*** Kill line

And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c k l") 'kill-whole-line)
#+END_SRC

*** Copy Line
Copies the line with current cursor.
#+BEGIN_SRC emacs-lisp
(defun my/copy-line (arg)
      "Copy lines (as many as prefix argument) in the kill ring"
      (interactive "p")
      (kill-ring-save (line-beginning-position)
                      (line-beginning-position (+ 1 arg)))
      (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(global-set-key "\C-c\C-k" 'my/copy-line)
#+END_SRC

*** Undo tree
Useful to visualize the undo actions
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** popup kill ring
Shows kill ring in popup. Works C-n and C-p to move across.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :diminish popup-kill-ring-mode
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

*** zapping

Very useful ! Kills everything from cursor to the char!
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC

*** OSX clipboard
OSX clipboard
#+BEGIN_SRC emacs-lisp
(use-package osx-clipboard
  :diminish osx-clipboard-mode
  :config
  (osx-clipboard-mode +1))
#+END_SRC
*** Clipmon
#+begin_src emacs-lisp
(use-package clipmon
  :init (progn (setq clipmon-action 'kill-new clipmon-timeout nil clipmon-sound nil clipmon-cursor-color nil clipmon-suffix nil) (clipmon-mode)))
#+end_src
*** File end with new line
if not add a new line at end of file
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC
*** Sentence end with single space
Sentences end with a single space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Kill spaces before save
delete trailing whitespaces
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Scrolling conservatively
Scroll conservatively, easy on eyes.
#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100)
#+END_SRC
*** Dumb jump

Dumb jump to move around and back.
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :diminish dumb-jump-mode
  :config
  (setq dumb-jump-selector 'helm)
  :init
  (dumb-jump-mode))

(defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("n" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("p" dumb-jump-back "Back"))

(global-set-key (kbd "M-g") 'dumb-jump-hydra/body)

#+END_SRC
*** Auto revert from disc
*** Grep a lot
Yeah, save grep results into temp buffers.
#+BEGIN_SRC emacs-lisp
(use-package grep-a-lot)
#+END_SRC

*** Git gutter
Shows good gutter icons !
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
    :diminish git-gutter-mode
    :init
  (global-git-gutter-mode +1))
#+END_SRC

*** Electric

Useful when you would not want to type everything.
Does what it says.
 #+BEGIN_SRC emacs-lisp
 (setq electric-pair-pairs '(
                            (?\{ . ?\})
                            (?\( . ?\))
                            (?\[ . ?\])
                            (?\" . ?\")
                            ))
 (electric-pair-mode t)
 #+END_SRC

*** Show parens

 It highlights matching parens when the cursor is just behind one of them.
 #+BEGIN_SRC emacs-lisp
   (show-paren-mode 1)
 #+END_SRC

*** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** Smartscan
M-n and M-p to move between the symbol matching the current location.
Moving to next symbol is easy.
#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :config (global-smartscan-mode t))
#+END_SRC

*** Visually indicate parentheses

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0.0)
#+END_SRC

** Navigation
*** File and directory management
**** Rename file and buffer
Renames current file and buffer.
#+BEGIN_SRC emacs-lisp
(defun my/rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))

(global-set-key (kbd "C-c r")  'my/rename-file-and-buffer)

#+END_SRC
**** Create directory recursively

create directory recursively if does not exists.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
             (when buffer-file-name
               (let ((dir (file-name-directory buffer-file-name)))
                 (when (and (not (file-exists-p dir))
                            (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                   (make-directory dir t))))))
#+END_SRC
**** Neotree
Sometimes I use neotree
#+BEGIN_SRC emacs-lisp

;; All The Icons
(use-package all-the-icons)

;; NeoTree
(use-package neotree
  :diminish neotree-mode
  :init
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))

#+END_SRC

*** Bookmarking
*** Back to mark
Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Moving between windows - windmove and ace window

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).

#+BEGIN_SRC emacs-lisp
(use-package windmove)
(windmove-default-keybindings)
#+END_SRC

Ace window numbers window when there are more than 2 windows.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("C-x o" . ace-window)))
#+END_SRC

*** TODO Layout Store and Restore
*** TODO swapping the buffers
*** Frequent accessed files
*** Recent files

#+BEGIN_SRC emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode)
#+END_SRC

*** Dired
*** helm-swoop - easy search in buffers
Easiest Way to search for a buffer or between multiple buffers.
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
 :bind
 (("C-S-s" . helm-swoop)
  ("M-i" . helm-swoop)
  ("M-s s" . helm-swoop)
  ("M-s M-s" . helm-swoop)
  ("M-I" . helm-swoop-back-to-last-point)
  ("C-c M-i" . helm-multi-swoop)
  ("C-x M-i" . helm-multi-swoop-all)
  )
 :config
 (progn
   (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
   (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
)
#+END_SRC
*** Smart move start of line
Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'my/smarter-move-beginning-of-line)
#+END_SRC

** Search

#+begin_src emacs-lisp
  (use-package engine-mode
    :config
    (progn
      (defengine mail "https://mail.google.com/mail/u/0/#search/%s" :keybinding "m")
      (defengine google "http://google.com/search?q=%s" :keybinding "g")
      (defengine amazon "https://is.amazon.com/search/all/?q=%s" :keybinding "a")
      (defengine emacswiki "http://google.com/search?q=site:emacswiki.org+%s" :keybinding "e")
      (bind-key* "C-c /" 'my/engine-mode-hydra/body)
      (engine-mode)))
#+end_src

** Email
*** mu4e

#+BEGIN_SRC emacs-lisp
;; make sure mu4e is in your load-path
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
(require 'mu4e)
(require 'smtpmail)
(setq mu4e-mu-binary "/usr/local/bin/mu")
(setq mu4e-maildir "~/Mail")

(setq mu4e-sent-folder "/Amazon/Sent Items"
      mu4e-drafts-folder "/Amazon/Drafts"
      mu4e-trash-folder  "/Amazon/Deleted Items"
      user-mail-address "nsalunke@amazon.com"
      smtpmail-default-smtp-server "ballard.amazon.com"
      smtpmail-local-domain "amazon.com"
      smtpmail-smtp-user "ANT\\nsalunke"
      smtpmail-smtp-server "ballard.amazon.com"
      smtpmail-stream-type 'starttls
      smtpmail-smtp-service 1587)

(setq mu4e-get-mail-command "fish;offlineimap"
      send-mail-function 'smtpmail-send-it
      message-kill-buffer-on-exit t)

(defun my-mu4e-html2text (msg)
  "My html2text function; shows short message inline, show
long messages in some external browser (see `browse-url-generic-program')."
  (let ((html (or (mu4e-message-field msg :body-html) "")))
    (if (> (length html) 20000)
      (progn
        (mu4e-action-view-in-browser msg)
        "[Viewing message in external browser]")
      (mu4e-shr2text msg))))

(setq mu4e-html2text-command 'my-mu4e-html2text)

 (setq mu4e-html2text-command
       "textutil -stdin -format html -convert txt -stdout")
;;(setq mu4e-html2text-command "w3m -T text/html")

;; you can quickly switch to your Inbox -- press ja
(setq mu4e-maildir-shortcuts
      '(("/Amazon/INBOX"               . ?a)
      '(("/Amazon/Sent Items"               . ?s)
      ;; Add others if needed.
       ))
;; http://www.djcbsoftware.nl/code/mu/mu4e/Bookmarks.html
;; Add new bookmarks to searches -- press br
(add-to-list 'mu4e-bookmarks
	     '("from:pipelines or from:p4admin"
	       "Trash to Delete"
	       ?r))
(global-set-key (kbd "C-x m") 'mu4e)
#+END_SRC

** Hydras
Finding it very useful.
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :config
    (defhydra my/engine-mode-hydra (:color blue)
      "Engine mode"
      ("m" engine/search-mail "mail")
      ("g" engine/search-google "google")
      ("a" engine/search-amazon "amazon")
      ("e" engine/search-emacswiki "emacswiki"))
    (defhydra my/key-chord-commands ()
      "Main"
      ("f" find-file "file" :color blue)
      ("c" (call-interactively 'org-capture) "capture" :color blue)
      ("w" my/engine-mode-hydra/body "web" :exit t)
      ("x" my/org-finish-previous-task-and-clock-in-new-one "Finish and clock in" :color blue)
      ("i" my/org-quick-clock-in-task "Clock in" :color blue)
      ("o" my/org-off-my-computer :color blue)
      ("t" (org-capture nil "T") "Capture task")
      ("h" my/org-jump :color blue)
      ("L" my/org-insert-link)
      ("+" text-scale-increase)
      ("-" text-scale-decrease))
    (defhydra my/quantified-hydra (:color blue)
      "Quick tracking of Quantified Awesome stuff"
      ("m" (my/org-clock-in-and-track-by-name "Work-Meeting") "Meeting")
      ("f" (my/org-clock-in-and-track-by-name "Family") "Family")
      ("r" (my/org-clock-in-and-track-by-name "Read") "Reading")
      ("w" (my/org-clock-in-and-track-by-name "Walk for 30+ minutes") "Walk")
      ("W" (my/org-clock-in-and-track-by-name "Write") "Write")
      ("r" (my/org-clock-in-and-track-by-name "Personal routines") "Routines")
      ("R" (my/org-clock-in-and-track-by-name "Relax") "Relax")
      ("l" (my/org-clock-in-and-track-by-name "Eat lunch") "Lunch")
      ("d" (my/org-clock-in-and-track-by-name "Eat dinner") "Dinner")
      ("e" (my/org-clock-in-and-track-by-name "Process my inbox") "E-mail")
      )
    (defhydra my/org (:color blue)
      "Convenient Org stuff."
      ("p" my/org-show-active-projects "Active projects")
      ("a" (org-agenda nil "a") "Agenda"))
    (defhydra my/window-movement ()
      ("<left>" windmove-left)
      ("<right>" windmove-right)
      ("<down>" windmove-down)
      ("<up>" windmove-up)
      ("y" other-window "other")
      ("h" switch-window "switch-window")
      ("f" helm-find-files "file")
      ("F" find-file-other-window "other file")
      ("v" (progn (split-window-right) (windmove-right)))
      ("o" delete-other-windows :color blue)
      ("a" ace-window)
      ("s" ace-swap-window)
      ("d" delete-window "delete")
      ("D" ace-delete-window "ace delete")
      ("i" ace-maximize-window "maximize")
      ("b" helm-buffers-list)
      ("q" nil))
    )
  (defun my/org-insert-link ()
    (interactive)
    (when (org-in-regexp org-bracket-link-regexp 1)
      (goto-char (match-end 0))
      (insert "\n"))
    (call-interactively 'org-insert-link))
#+END_SRC

** KeyChords

#+BEGIN_SRC emacs-lisp
  (defun my/key-chord-define (keymap keys command)
    "Define in KEYMAP, a key-chord of two keys in KEYS starting a COMMAND.
  \nKEYS can be a string or a vector of two elements. Currently only elements
  that corresponds to ascii codes in the range 32 to 126 can be used.
  \nCOMMAND can be an interactive function, a string, or nil.
  If COMMAND is nil, the key-chord is removed.

  MODIFICATION: Do not define the transposed key chord.
  "
    (if (/= 2 (length keys))
        (error "Key-chord keys must have two elements"))
    ;; Exotic chars in a string are >255 but define-key wants 128..255 for those
    (let ((key1 (logand 255 (aref keys 0)))
          (key2 (logand 255 (aref keys 1))))
      (define-key keymap (vector 'key-chord key1 key2) command)))
  (fset 'key-chord-define 'my/key-chord-define)

  (defun my/switch-to-previous-buffer ()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :init
    (progn
      (fset 'key-chord-define 'my/key-chord-define)
      (setq key-chord-one-key-delay 0.16)
      (key-chord-mode 1)
      (key-chord-define-global "JJ"     'my/switch-to-previous-buffer)
      (key-chord-define-global "kk"     'kill-whole-line)
      (key-chord-define-global "yy"    'my/window-movement/body)
      (key-chord-define-global "hh"     'my/key-chord-commands/body)
      (key-chord-define-global "qq"     'my/quantified-hydra/body)
      (key-chord-define-global "uu"     'undo)
      (key-chord-define-global "FF"     'find-file)))
#+END_SRC

#+begin_src emacs-lisp(
(bind-key "C-t" 'my/key-chord-commands/body)
#+end_src
** Calendor
*** gcal

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :config
  (setq org-gcal-client-id "..."
	org-gcal-client-secret "..."
	org-gcal-file-alist '(("salunkenagesh14@gmail.com" .  "~/personal/org/gcal.org"))))

(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) ))

#+END_SRC

** IRC
*** TODO rcirc
  #+BEGIN_SRC emacs-lisp
  (use-package rcirc
    :init
    (setq rcirc-default-nick "nsalunke"
	rcirc-default-user-name "Nagesh"
	rcirc-default-full-name "Nagesh Salunke"
	rcirc-debug-flag t
	rcirc-log-flag t
	rcirc-time-format "%Y-%m-%d %H:%M "
	rcirc-server-alist '(("irc.freenode.net"
                              :channels (
					 "#emacs"
					 "#go-nuts"
					 "#rubyonrails"
				          "#reactjs"
					 ))
                             )
	rcirc-authinfo '(("freenode" nickserv "nsalunke" "nagesh"))
	))

  ;; Don't print /away messages.
  ;; This does not require rcirc to be loaded already,
  ;; since rcirc doesn't define a 301 handler (yet).
  (defun rcirc-handler-301 (process cmd sender args)
    "/away message handler.")


  ;; Turn on spell checking.
  (add-hook 'rcirc-mode-hook 'turn-on-flyspell)

  ;; Keep input line at bottom.
  (add-hook 'rcirc-mode-hook
            (lambda ()
              (set (make-local-variable 'scroll-conservatively)
                   8192)))


  ;; Adjust the colours of one of the faces.
  (set-face-foreground 'rcirc-my-nick "red" nil)
  #+END_SRC

** Reading Blogs
*** Elfeed

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :config
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/.emacs.d/config.org")))

(use-package elfeed-goodies
  :config
  (elfeed-goodies/setup))

(global-set-key (kbd "C-x w") 'elfeed)
#+END_SRC

*** Blog list
:PROPERTIES:
:ID: elfeed
:END:

**** Javascript                                                  :javascript:
***** http://feeds.feedburner.com/2ality

**** News
***** https://news.ycombinator.com/rss

**** Other coding and interest
***** https://facebook.github.io/react/feed.xml
***** https://nageshrsalunke.me/feed.xml                         :myblog:
***** https://harryrschwartz.com/atom.xml
***** http://blog.samaltman.com/posts.atom
**** Emacs
***** http://oremacs.com/atom.xml
***** http://endlessparentheses.com/atom.xml
***** http://pragmaticemacs.com/feed/
***** https://www.reddit.com/r/emacs/.rss
***** http://sachachua.com/blog/category/emacs/feed/              :sachachua:
***** http://planet.emacsen.org/atom.xml
***** http://ergoemacs.org/emacs/blog.xml

** Programming
*** Autocomplete - company
Company mode
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :init (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

*** TODO Yasnippet
Basic yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-mode
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1))
#+END_SRC
*** Magit - Reason why wanted to learn emacs ! :D

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (add-hook 'magit-log-edit-mode-hook 'turn-on-auto-fill)
  (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
  :bind
   ( "C-c g" . 'magit-status))

  ;; From http://endlessparentheses.com/merging-github-pull-requests-from-emacs.html
  (defun endless/load-gh-pulls-mode ()
    "Start `magit-gh-pulls-mode' only after a manual request."
    (interactive)
    (require 'magit-gh-pulls)
    (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)
    (magit-gh-pulls-mode 1)
    (magit-gh-pulls-reload))
(use-package magit-gh-pulls)
(defvar magit-last-seen-setup-instructions "1.4.0")
#+END_SRC

Magit status in full frame.
#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :init
  (fullframe magit-status magit-mode-quit-window nil))
#+END_SRC

The proper way to implement this is probably to patch or override the
definition of magit-git-insert-section so that it takes a list of
options to add at the end of the command, but that can wait for another time (or braver souls).

**** TODO Make this better by adding a post command options variable
*** git-messenger - shows commit message
Useful, has more details than just popup, saves time  to visit the code repository
#+BEGIN_SRC emacs-lisp
(use-package git-messenger
  :bind (("C-c v m" . git-messenger:popup-message)))
#+END_SRC
** Projects
*** Projectile basic
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (setq projectile-require-project-root nil)
  (setq projectile-completion-system 'helm)
  (setq projectile-indexing-method 'alien)
  :config
  (projectile-global-mode 1))
#+END_SRC
** Org
*** Org Files

 | FileName      | location                      | Subheadings           | Purpose                                             |
 |---------------+-------------------------------+-----------------------+-----------------------------------------------------|
 | organizer.org | ~/personal/organizer.org      | Inbox                 | All incoming for org capture.                       |
 |               |                               | Quick Notes           | C-c c captures, tasks, todos                        |
 | amazon.org    | ~/personal/org/amazon.org     | Team                  | Work Items Project, on call meetings                |
 |               |                               | - Projects >          | random and journal entries                          |
 |               |                               | - On-Call             |                                                     |
 |               |                               | - Meetings            |                                                     |
 |               |                               | - Random              |                                                     |
 |               |                               | - UnCategorized       |                                                     |
 |               |                               | - Journal             |                                                     |
 | appideas      | ~/personal/org/app.org        | NA                    | to capture ideas for apps                           |
 | blogs         | ~/personal/org/blogs.org      | Blogs Writing Ideas   | Blog Writing ideas                                  |
 |               |                               | Blogs to Read         | Links for Blogs to read                             |
 | books         | ~/personal/org/books.org      | Books to  Read        | Books to Read                                       |
 |               |                               | (Categories)          |                                                     |
 | dailynotes    | ~/personal/org/dailynotes.org | Journal file          | Daily notes on anything                             |
 | dailytasks    | ~/personal/org/dailytasks.org | Journal file          | Daily Tasks organization - Checklist                |
 | family        | ~/personal/org/family.org     | Family Work           | Family specific tasks and tasks people ask me to do |
 |               |                               | Vacation              |                                                     |
 |               |                               | Other                 |                                                     |
 | finance       | ~/personal/org/finance.org    | Expenses              | expenses                                            |
 |               |                               | Bill payments         | Bill payments to make                               |
 |               |                               | Income                | Income sources                                      |
 | journal       | ~/personal/org/journal.org    | Journal               |                                                     |
 | learn         | ~/personal/org/learn.org      | <Categories>          | Learning for each categories, tasks and notes       |
 | people        | ~/personal/org/contacts.org   | Contact               |                                                     |
 |               |                               | Inspirational People  |                                                     |
 | personal      | ~/personal/org/personal.org   | Personal Improvements | personal improvements tasks                         |
 |               |                               | Personal Work         | personal work items                                 |
 | reviews       | ~/personal/org/reviews.org    | Journal               | Weekly review Journal                               |
 |               |                               |                       | Monthly review Journal                              |
 | life          | ~/personal/org/life.org       | TBD                   | Things that I would want to track for life          |
 |               |                               |                       |                                                     |
 |---------------+-------------------------------+-----------------------+-----------------------------------------------------|

*** Modules
Org has a whole bunch of optional modules. I plan to learn one by one.

#+BEGIN_SRC emacs-lisp
  (setq org-modules '(org-bbdb
                      org-gnus
                      org-drill
                      org-info
                      org-jsinfo
                      org-habit
                      org-irc
                      org-mouse
                      org-protocol
                      org-annotate-file
                      org-eval
                      org-expiry
                      org-interactive-query
                      org-man
                      org-collector
                      org-panel
                      org-screen
                      org-toc))
(eval-after-load 'org
 '(org-load-modules-maybe t))
;; Prepare stuff for org-export-backends
(setq org-export-backends '(org latex icalendar html ascii))
#+END_SRC

*** Shortcuts
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'org-capture)
(bind-key "C-c a" 'org-agenda)
(bind-key "C-c l" 'org-store-link)
(bind-key "C-c L" 'org-insert-link-global)
(bind-key "C-c O" 'org-open-at-point-global)
(bind-key "<f9> <f9>" 'org-agenda-list)
(bind-key "<f9> <f8>" (lambda () (interactive) (org-capture nil "r")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (bind-key "C-M-w" 'append-next-kill org-mode-map)
  (bind-key "C-TAB" 'org-cycle org-mode-map)
  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)
  (bind-key "C-c o" 'my/org-follow-entry-link org-mode-map)
  (bind-key "C-c d" 'my/org-move-line-to-destination org-mode-map)
  (bind-key "C-c C-p C-p" 'my/org-publish-maybe org-mode-map)
  (bind-key "C-c C-r" 'my/org-refile-and-jump org-mode-map))

(with-eval-after-load 'org-agenda
  (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+END_SRC

*** Speed commands
#+BEGIN_SRC emacs-lisp
(setq org-use-effective-time t)

(defun my/org-use-speed-commands-for-headings-and-lists ()
     "Activate speed commands on list items too."
     (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
         (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
   (setq org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)

(with-eval-after-load 'org
   (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
   (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
   (add-to-list 'org-speed-commands-user '("!" my/org-clock-in-and-track))
   (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
   (add-to-list 'org-speed-commands-user '("d" my/org-move-line-to-destination))
   (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
   (add-to-list 'org-speed-commands-user '("P" call-interactively 'org2blog/wp-post-subtree))
   (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
   (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
   (bind-key "!" 'my/org-clock-in-and-track org-agenda-mode-map))
#+END_SRC

*** Navigation
#+BEGIN_SRC emacs-lisp
(setq org-goto-interface 'outline
      org-goto-max-level 10)
(require 'imenu)
(setq org-startup-folded nil)
(bind-key "C-c j" 'org-clock-goto) ;; jump to current task from anywhere
(bind-key "C-c C-w" 'org-refile)
(setq org-cycle-include-plain-lists 'integrate)
#+END_SRC

**** Cut subtrees
 #+BEGIN_SRC emacs-lisp
 (with-eval-after-load 'org
      (bind-key "C-c k" 'org-cut-subtree org-mode-map)
      (setq org-yank-adjusted-subtrees t))
 #+END_SRC

*** Taking Notes

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/personal")
(setq org-default-notes-file "~/personal/organizer.org")
#+END_SRC

This makes it easier to add links from outside.

#+begin_src emacs-lisp
(defun my/yank-more ()
  (interactive)
  (insert "[[")
  (yank)
  (insert "][more]]"))
(global-set-key (kbd "<f6>") 'my/yank-more)
#+end_src

**** Org Capture templates

   #+BEGIN_SRC emacs-lisp
 (defvar my/org-basic-task-template "* TODO %^{Task}
 :PROPERTIES:
 :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
 :END:
 Captured %<%Y-%m-%d %H:%M>
 %?

%i"
"Basic task data")

 (setq org-capture-templates
           `(("t" "Tasks" entry
              (file+headline "~/personal/organizer.org" "Inbox"),
	      my/org-basic-task-template)

	     ("a" "Appointment" entry (file  "~/personal/org/gcal.org" )
	    "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")

	     ("T" "Quick task" entry
              (file+headline "~/personal/organizer.org" "Inbox")
              "* TODO %^{Task}\nSCHEDULED: %t\n"
              :immediate-finish t)

	     ("i" "Interrupting task" entry
              (file+headline "~/personal/organizer.org" "Inbox")
              "* STARTED %^{Task}"
              :clock-in :clock-resume)

	      ("I" "App idea" entry
              (file+headline "~/personal/org/app.org" "AppIdeas")
              "* TODO %^{Task}"
              :immediate-finish t)

              ("w" "Amazon work task" entry
              (file+headline+datetree "~/personal/org/amazon.org" "UnorganizedTasks"),
	      my/org-basic-task-template)

              ("p" "People task" entry
              (file+headline "~/personal/org/people.org" "UnorganizedTasks")
              ,my/org-basic-task-template)

              ("dt" "Done - Task" entry
              (file+headline "~/personal/organizer.org" "Inbox")
              "* DONE %^{Task}\nSCHEDULED: %^t\n%?")

              ("q" "Quick note" item
              (file+headline "~/personal/organizer.org" "Quick notes"))

	      ("j" "Journal entry" plain
              (file+datetree "~/personal/org/journal.org")
              "%K - %a\n%i\n%?\n"
              :unnarrowed t)

              ("J" "Journal entry with date" plain
              (file+datetree+prompt "~/personal/org/journal.org")
              "%K - %a\n%i\n%?\n"
              :unnarrowed t)

              ("s" "Journal entry with date, scheduled" entry
              (file+datetree+prompt "~/personal/org/journal.org")
              "* \n%K - %a\n%t\t%i\n%?\n"
              :unnarrowed t)

	      ("l" "Ledger entries")

	      ("la" "AMX" plain
              (file "~/personal/org/ledger")
              "%(org-read-date) %^{Payee}
	      Liabilities:AX
	      Expenses:%^{Account}  $%^{Amount}
	      " :immediate-finish t)

	      ("li" "IC" plain
              (file "~/personal/org/ledger")
              "%(org-read-date) %^{Payee}
	      Liabilities:IC
	      Expenses:%^{Account}  $%^{Amount}
	      " :immediate-finish t)

              ("lc" "Cash" plain
              (file "~/personal/ledger")
              "%(org-read-date) * %^{Payee}
	      Expenses:Cash
	      Expenses:%^{Account}  %^{Amount}")

              ("B" "Book" entry
              (file+headline "~/personal/org/books.org" "Book to Read"))

              ("n" "Daily Notes" table-line (file+olp "~/personal/organizer.org" "Inbox")
               "| %u | %^{Note} |"
               :immediate-finish t)

	       ("P" "Contact" entry
	       (file "~/personal/org/contacts.org")
	       "* %^{name}
:PROPERTIES:
:EMAIL: %^{email}
:END:")

	       ("r" "Notes" entry
               (file+datetree "~/personal/org/dailynotes.org")
               "* %?\n\n%i\n%U\n")

	       ))
   #+END_SRC

**** Refile in middle of capture
#+BEGIN_SRC emacs-lisp
(defun my/org-refile-and-jump ()
  (interactive)
  (if (derived-mode-p 'org-capture-mode)
      (org-capture-refile)
    (call-interactively 'org-refile))
  (org-refile-goto-last-stored))

(eval-after-load 'org-capture
 '(bind-key "C-c C-r" 'my/org-refile-and-jump org-capture-mode-map))
#+END_SRC


*** Templates
***** Structure templates

  Org makes it easy to insert blocks by typing =<s[TAB]=, etc.

  #+begin_src emacs-lisp
    (setq org-structure-template-alist
          '(("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>")
            ("H" "#+html: " "<literal style=\"html\">?</literal>")
            ("a" "#+begin_ascii\n?\n#+end_ascii")
            ("A" "#+ascii: ")
            ("I" "#+include %file ?" "<include file=%file markup=\"?\">")))
  #+end_src

*** Refiling
Refiling helps you to move under headlines.

#+BEGIN_SRC emacs-lisp
(setq org-reverse-note-order t)
(setq org-refile-use-outline-path nil)
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-refile-use-cache nil)
(setq org-refile-targets '((nil :maxlevel . 9)
                                  (org-agenda-files :maxlevel . 9)))
(setq org-blank-before-new-entry nil)
#+END_SRC

**** TEACH Jump to Org location by substring

 #+BEGIN_SRC emacs-lisp
 (defun my/org-refile-get-location-by-substring (regexp &optional file)
   "Return the refile location identified by REGEXP."
   (let ((org-refile-targets org-refile-targets) tbl)
     (setq org-refile-target-table (org-refile-get-targets)))
   (unless org-refile-target-table
     (user-error "No refile targets"))
   (cl-find regexp org-refile-target-table
            :test
            (lambda (a b)
              (and
               (string-match a (car b))
               (or (null file)
                   (string-match file (elt b 1)))))))

 (defun my/org-refile-subtree-to (name)
   (org-refile nil nil (my/org-refile-get-location-exact name)))

  (defun my/org-refile-get-location-exact (name &optional file)
   "Return the refile location identified by NAME."
   (let ((org-refile-targets org-refile-targets) tbl)
     (setq org-refile-target-table (org-refile-get-targets)))
   (unless org-refile-target-table
     (user-error "No refile targets"))
   (cl-find name org-refile-target-table
            :test (lambda (a b)
                  (and (string-equal a (car b))
               (or (null file)
                   (string-match file (elt b 1)))))))

 ;; Example: (my/org-clock-in-refile "Off my computer")
  (defun my/org-clock-in-refile (location &optional file)
   "Clocks into LOCATION.
 LOCATION and FILE can also be regular expressions for `my/org-refile-get-location-by-substring'."
   (interactive (list (my/org-refile-get-location)))
   (save-window-excursion
     (save-excursion
       (if (stringp location) (setq location (my/org-refile-get-location-by-substring location file)))
       (org-refile 4 nil location)
       (org-clock-in))))

  (defun my/org-finish-previous-task-and-clock-in-new-one (location &optional file)
   (interactive (list (my/org-refile-get-location)))
   (save-window-excursion
     (org-clock-goto)
     (org-todo 'done))
   (my/org-clock-in-and-track-by-name location file))

 (defun my/org-clock-in-and-track-by-name (location &optional file)
   (interactive (list (my/org-refile-get-location)))
   (save-window-excursion
     (save-excursion
       (if (stringp location) (setq location (my/org-refile-get-location-exact location file)))
       (org-refile 4 nil location)
       (my/org-clock-in-and-track))))

 (defun my/org-off-my-computer (category)
   (interactive "MCategory: ")
   (my/org-clock-in-refile "Off my computer")
   (quantified-track category))
 #+END_SRC

**** Jumping

#+BEGIN_SRC emacs-lisp
(defun my/org-jump ()
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively 'org-refile)))
#+END_SRC

*** Tasks

**** Track TODO state

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
 '((sequence
    "TODO(t)"  ; next action
    "STARTED(s)"
    "WAITING(w@/!)"
    "HOLD(h@/!)"
    "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
   (sequence "LEARN" "TRY"  "|" "COMPLETE(x)")
   (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      '(("TODO" . (:foreground "green" :weight bold))
        ("DONE" . (:foreground "cyan" :weight bold))
        ("WAITING" . (:foreground "red" :weight bold))
        ("HOLD" . (:foreground "orange" :weight bold))
        ("SOMEDAY" . (:foreground "gray" :weight bold))))
#+END_SRC

#+BEGIN_SRC emacs-lis
(setq org-log-done 'time)
#+END_SRC

**** Projects

Projects are headings with the :project: tag, so we generally don’t want that tag inherited,
except when we display unscheduled tasks that don’t belong to any projects.

#+BEGIN_SRC emacs-lisp
(setq org-tags-exclude-from-inheritance '("project"))
#+END_SRC

This code makes it easy for me to focus on one project and its tasks.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-speed-commands-user '("N" org-narrow-to-subtree))
(add-to-list 'org-speed-commands-user '("W" widen))

(defun my/org-agenda-for-subtree ()
  (interactive)
  (when (derived-mode-p 'org-agenda-mode) (org-agenda-switch-to))
  (my/org-with-current-task
   (let ((org-agenda-view-columns-initially t))
     (org-agenda nil "t" 'subtree))))
(add-to-list 'org-speed-commands-user '("T" my/org-agenda-for-subtree))
#+END_SRC

Sorting

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-speed-commands-user '("S" call-interactively 'org-sort))
#+END_SRC

**** Tag tasks with GTD-ish contexts

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("@work" . ?b)
			("@home" . ?h)
			("@errands" . ?e)
			("@coding" . ?c)
			("@reading" . ?r)
			("@learning" . ?l)
			("quantified" . ?q)
			("app" . ?0)
			("urgent" .?u)
			("inspiration" . ?i)))
#+END_SRC

**** Enable filtering by effort estimates

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-global-properties
      '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00"))
#+END_SRC

**** Track time

#+BEGIN_SRC emacs-lisp
(use-package org
 :init
 (progn
  (setq org-expiry-inactive-timestamps t)
  (setq org-clock-idle-time nil)
  (setq org-log-done 'time)
  (setq org-clock-continuously nil)
  (setq org-clock-persist t)
  (setq org-clock-in-switch-to-state "STARTED")
  (setq org-clock-in-resume nil)
  (setq org-show-notification-handler 'message)
  (setq org-clock-report-include-clocking-task t))
 :config
  (org-clock-persistence-insinuate))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer "LOGBOOK")
(setq org-clock-into-drawer 1)
#+END_SRC

**** Habits

#+BEGIN_SRC emacs-lisp
(setq org-habit-graph-column 80)
(setq org-habit-show-habits-only-for-today nil)
#+END_SRC

**** Estimating tasks
 From “Add an effort estimate on the fly when clocking in”

 #+BEGIN_SRC emacs-lisp
 (add-hook 'org-clock-in-prepare-hook
           'my/org-mode-ask-effort)

 (defun my/org-mode-ask-effort ()
   "Ask for an effort estimate when clocking in."
   (unless (org-entry-get (point) "Effort")
     (let ((effort
            (completing-read
             "Effort: "
             (org-entry-get-multivalued-property (point) "Effort"))))
       (unless (equal effort "")
         (org-set-property "Effort" effort)))))
 #+END_SRC

**** Modifying org agenda so that I can display a subset of tasks
 I want to create an agenda command that displays a list of tasks by context.
 That way, I can quickly preview a bunch of contexts and decide what I feel like doing the most.

 #+BEGIN_SRC emacs-lisp
 (defvar my/org-agenda-limit-items nil "Number of items to show in agenda to-do views; nil if unlimited.")
 (eval-after-load 'org
 '(defadvice org-agenda-finalize-entries (around sacha activate)
   (if my/org-agenda-limit-items
       (progn
         (setq list (mapcar 'org-agenda-highlight-todo list))
         (setq ad-return-value
               (subseq list 0 my/org-agenda-limit-items))
         (when org-agenda-before-sorting-filter-function
           (setq list (delq nil (mapcar org-agenda-before-sorting-filter-function list))))
         (setq ad-return-value
               (mapconcat 'identity
                          (delq nil
				(subseq
                                 (sort list 'org-entries-lessp)
                                 0
                                 my/org-agenda-limit-items))
                          "\n")))
     ad-do-it)))
 #+END_SRC

**** Task dependencies

 #+BEGIN_SRC emacs-lisp
 (setq org-enforce-todo-dependencies t)
 (setq org-track-ordered-property-with-tag t)
 (setq org-agenda-dim-blocked-tasks t)
 #+END_SRC

*** Org Agenda

**** Basic config
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))

(use-package org-bullets
  :init
  (add-hook 'org-mode-hook #'org-bullets-mode))

(setq org-agenda-files (quote ("~/personal/organizer.org"
			       "~/personal/org/amazon.org"
			       "~/personal/org/personal.org"
			       "~/personal/org/learn.org"
			       "~/personal/org/finance.org"
			       "~/personal/org/family.org"
			       "~/personal/org/app.org"
			       "~/personal/org/people.org"
			       "~/personal/org/dailytasks.org"
			       "~/personal/org/gcal.org")))

#+END_SRC

I like looking at 7 days at a time when I plan using the Org agenda.
I want to see my log entries, but I don’t want to see scheduled items that I’ve finished.
I like seeing a time grid so that I can get a sense of how appointments are spread out.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 7)
(setq org-agenda-tags-column -100) ; take advantage of the screen width
(setq org-agenda-sticky nil)
(setq org-agenda-inhibit-startup t)
(setq org-agenda-use-tag-inheritance t)
(setq org-agenda-show-log t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
(setq org-agenda-time-grid
      '((daily today require-timed)
       "----------------"
       (800 1000 1200 1400 1600 1800)))
(setq org-columns-default-format "%14SCHEDULED %Effort{:} %1PRIORITY %TODO %50ITEM %TAGS")
(bind-key "Y" 'org-agenda-todo-yesterday org-agenda-mode-map)

#+END_SRC

Start week on Sunday
#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday 1)
#+END_SRC

**** Display projects with associated subtasks

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-project-agenda ()
  "Return the project headline and up to `my/org-agenda-limit-items' tasks."
  (save-excursion
    (let* ((marker (org-agenda-new-marker))
           (heading
            (org-agenda-format-item "" (org-get-heading) (org-get-category) nil))
           (org-agenda-restrict t)
           (org-agenda-restrict-begin (point))
           (org-agenda-restrict-end (org-end-of-subtree 'invisible))
           ;; Find the TODO items in this subtree
           (list (org-agenda-get-day-entries (buffer-file-name) (calendar-current-date) :todo)))
      (org-add-props heading
          (list 'face 'defaults
                'done-face 'org-agenda-done
                'undone-face 'default
                'mouse-face 'highlight
                'org-not-done-regexp org-not-done-regexp
                'org-todo-regexp org-todo-regexp
                'org-complex-heading-regexp org-complex-heading-regexp
                'help-echo
                (format "mouse-2 or RET jump to org file %s"
                        (abbreviate-file-name
                         (or (buffer-file-name (buffer-base-buffer))
                             (buffer-name (buffer-base-buffer))))))
        'org-marker marker
        'org-hd-marker marker
        'org-category (org-get-category)
        'type "tagsmatch")
      (concat heading "\n"
              (org-agenda-finalize-entries list)))))

(defun my/org-agenda-projects-and-tasks (match)
  "Show TODOs for all `org-agenda-files' headlines matching MATCH."
  (interactive "MString: ")
  (let ((todo-only nil))
    (if org-agenda-overriding-arguments
        (setq todo-only (car org-agenda-overriding-arguments)
              match (nth 1 org-agenda-overriding-arguments)))
    (let* ((org-tags-match-list-sublevels
            org-tags-match-list-sublevels)
           (completion-ignore-case t)
           rtn rtnall files file pos matcher
           buffer)
      (when (and (stringp match) (not (string-match "\\S-" match)))
        (setq match nil))
      (when match
        (setq matcher (org-make-tags-matcher match)
              match (car matcher) matcher (cdr matcher)))
      (catch 'exit
        (if org-agenda-sticky
            (setq org-agenda-buffer-name
                  (if (stringp match)
                      (format "*Org Agenda(%s:%s)*"
                              (or org-keys (or (and todo-only "M") "m")) match)
                    (format "*Org Agenda(%s)*" (or (and todo-only "M") "m")))))
        (org-agenda-prepare (concat "TAGS " match))
        (org-compile-prefix-format 'tags)
        (org-set-sorting-strategy 'tags)
        (setq org-agenda-query-string match)
        (setq org-agenda-redo-command
              (list 'org-tags-view `(quote ,todo-only)
                    (list 'if 'current-prefix-arg nil `(quote ,org-agenda-query-string))))
        (setq files (org-agenda-files nil 'ifmode)
              rtnall nil)
        (while (setq file (pop files))
          (catch 'nextfile
            (org-check-agenda-file file)
            (setq buffer (if (file-exists-p file)
                             (org-get-agenda-file-buffer file)
                           (error "No such file %s" file)))
            (if (not buffer)
                ;; If file does not exist, error message to agenda
                (setq rtn (list
                           (format "ORG-AGENDA-ERROR: No such org-file %s" file))
                      rtnall (append rtnall rtn))
              (with-current-buffer buffer
                (unless (derived-mode-p 'org-mode)
                  (error "Agenda file %s is not in `org-mode'" file))
                (save-excursion
                  (save-restriction
                    (if org-agenda-restrict
                        (narrow-to-region org-agenda-restrict-begin
                                          org-agenda-restrict-end)
                      (widen))
                    (setq rtn (org-scan-tags 'my/org-agenda-project-agenda matcher todo-only))
                    (setq rtnall (append rtnall rtn))))))))
        (if org-agenda-overriding-header
            (insert (org-add-props (copy-sequence org-agenda-overriding-header)
                        nil 'face 'org-agenda-structure) "\n")
          (insert "Headlines with TAGS match: ")
          (add-text-properties (point-min) (1- (point))
                               (list 'face 'org-agenda-structure
                                     'short-heading
                                     (concat "Match: " match)))
          (setq pos (point))
          (insert match "\n")
          (add-text-properties pos (1- (point)) (list 'face 'org-warning))
          (setq pos (point))
          (unless org-agenda-multi
            (insert "Press `C-u r' to search again with new search string\n"))
          (add-text-properties pos (1- (point)) (list 'face 'org-agenda-structure)))
        (org-agenda-mark-header-line (point-min))
        (when rtnall
          (insert (mapconcat 'identity rtnall "\n") ""))
        (goto-char (point-min))
        (or org-agenda-multi (org-agenda-fit-window-to-buffer))
        (add-text-properties (point-min) (point-max)
                             `(org-agenda-type tags
                                               org-last-args (,todo-only ,match)
                                               org-redo-cmd ,org-agenda-redo-command
                                               org-series-cmd ,org-cmd))
        (org-agenda-finalize)
        (setq buffer-read-only t)))))
#+END_SRC

**** Org agenda custom commands

| Key          | 	Description                                                                            |
|--------------+------------------------------------------------------------------------------------------------|
| .            | What am I waiting for?                                                                         |
| T            | Not really an agenda command - shows the to-do tree in the current file                        |
| b            | Shows work-related tasks                                                                       |
| o            | Shows personal tasks and miscellaneous tasks (o: organizer)                                    |
| w            | Show all tasks for the upcoming week                                                           |
| W            | Show all tasks for the upcoming week, aside from the routine ones                              |
| g            | Show tasks by context: b - work; c - coding; l - learning; h - home                            |
| 0            | Show common contexts with up to 3 tasks each, so that I can choose what I feel like working on |
| )  (shift-0) | Show common contexts with all the tasks associated with them                                   |
| 9            | Show common contexts with up to 3 unscheduled tasks each                                       |
| ( (shift-9)  | Show common contexts with all the unscheduled tasks associated with them                       |
| d            | Timeline for today (agenda, clock summary)                                                     |
| u            | Unscheduled tasks to do if I have free time                                                    |
| U            | Unscheduled tasks that are not part of projects                                                |
| P            | Tasks by priority                                                                              |
| p            | My projects                                                                                    |
| 2            | Projects with tasks                                                                            |
|--------------+------------------------------------------------------------------------------------------------|

#+BEGIN_SRC emacs-lisp
(defvar my/org-agenda-contexts
  '((tags-todo "+@work")
    (tags-todo "+@coding")
    (tags-todo "+@reading")
    (tags-todo "+@learning")
    (tags-todo "+@home")
    (tags-todo "+@urgent")
    (tags-todo "+@errands"))
  "Usual list of contexts.")
(defun my/org-agenda-skip-scheduled ()
  (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp "\n]+>"))
(setq org-agenda-custom-commands
      `(("o" todo "all in organizer"
         ((org-agenda-files '("~/personal/organizer.org"))))
	 ("c" todo "Org agenda sorted"
         ((org-agenda-prefix-format "")
          (org-agenda-cmp-user-defined 'my/org-sort-agenda-items-todo)
          (org-agenda-view-columns-initially t)
          ))
        ("5" "Quick tasks" tags-todo "EFFORT>=\"0:05\"&EFFORT<=\"0:15\"")
        ("7" "Unestimated tasks" tags-todo "EFFORT=\"\"")
        ("gb" "Work" todo ""
         ((org-agenda-files '("~/personal/org/amazon.org"))
          (org-agenda-view-columns-initially t)))
        ("gc" "Coding" tags-todo "@coding"
         ((org-agenda-view-columns-initially t)))
        ("gr" "Reading" tags-todo "@reading"
         ((org-agenda-view-columns-initially t)))
        ("gl" "Learning" tags-todo "@learning"
         ((org-agenda-view-columns-initially t)))
        ("gu" "Urgent" tags-todo "@urgent"
         ((org-agenda-view-columns-initially t)))
        ("gh" "Home" tags-todo "@home"
         ((org-agenda-view-columns-initially t)))
        ("ge" "Errands" tags-todo "@errands"
         ((org-agenda-view-columns-initially t)))
        ("0" "Top 3 by context"
         ,my/org-agenda-contexts
         ((org-agenda-sorting-strategy '(priority-up effort-down))
          (my/org-agenda-limit-items 3)))
        (")" "All by context"
         ,my/org-agenda-contexts
         ((org-agenda-sorting-strategy '(priority-down effort-down))
          (my/org-agenda-limit-items nil)))
        ("9" "Unscheduled top 3 by context"
         ,my/org-agenda-contexts
         ((org-agenda-skip-function 'my/org-agenda-skip-scheduled)
          (org-agenda-sorting-strategy '(priority-down effort-down))
          (my/org-agenda-limit-items 3)))
        ("(" "All unscheduled by context"
         ,my/org-agenda-contexts
         ((org-agenda-skip-function 'my/org-agenda-skip-scheduled)
          (org-agenda-sorting-strategy '(priority-down effort-down))
          ))
        ("d" "Timeline for today" ((agenda "" ))
         ((org-agenda-ndays 1)
          (org-agenda-show-log t)
          (org-agenda-log-mode-items '(clock closed))
          (org-agenda-clockreport-mode t)
          (org-agenda-entry-types '())))
        ("." "Waiting for" todo "WAITING")
        ("u" "Unscheduled tasks" tags-todo "-someday-TODO=\"SOMEDAY\"-TODO=\"DELEGATED\"-TODO=\"WAITING\"-project"
         ((org-agenda-skip-function 'my/org-agenda-skip-scheduled)
          (org-agenda-view-columns-initially t)
          (org-tags-exclude-from-inheritance '("project"))
          (org-agenda-overriding-header "Unscheduled TODO entries: ")
          (org-columns-default-format "%50ITEM %TODO %3PRIORITY %Effort{:} %TAGS")
          (org-agenda-sorting-strategy '(todo-state-up priority-down effort-up tag-up category-keep))))
        ("U" "Unscheduled tasks outside projects" tags-todo "-project"
         ((org-agenda-skip-function 'my/org-agenda-skip-scheduled)
          (org-tags-exclude-from-inheritance nil)
          (org-agenda-view-columns-initially t)
          (org-agenda-overriding-header "Unscheduled TODO entries outside projects: ")
          (org-agenda-sorting-strategy '(todo-state-up priority-down tag-up category-keep effort-down))))
        ("pp" tags "+project-someday-TODO=\"DONE\"-TODO=\"SOMEDAY\"-inactive"
         ((org-tags-exclude-from-inheritance '("project"))
          (org-agenda-sorting-strategy '(priority-down tag-up category-keep effort-down))))
        ("p." tags "+project-TODO=\"DONE\""
         ((org-tags-exclude-from-inheritance '("project"))
          (org-agenda-sorting-strategy '(priority-down tag-up category-keep effort-down))))
        ("S" tags-todo "TODO=\"STARTED\"")
	("P" "By priority"
         ((tags-todo "+PRIORITY=\"A\"")
          (tags-todo "+PRIORITY=\"B\"")
          (tags-todo "+PRIORITY=\"\"")
          (tags-todo "+PRIORITY=\"C\"")))
        ("2" "List projects with tasks" my/org-agenda-projects-and-tasks
         "+PROJECT"
         ((my/org-agenda-limit-items 3)))))

(bind-key "<apps> a" 'org-agenda)
#+END_SRC

**** Make it easy to mark it done in agenda

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-done (&optional arg)
  "Mark current TODO as done.
This changes the line at point, all other lines in the agenda referring to
the same tree node, and the headline of the tree node in the Org-mode file."
  (interactive "P")
  (org-agenda-todo "DONE"))
;; Override the key definition for org-exit
(define-key org-agenda-mode-map "x" 'my/org-agenda-done)
#+END_SRC

**** Make it easy to mark a task as done and create a follow-up task

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-mark-done-and-add-followup ()
    "Mark the current TODO as done and add another task after it.
Creates it at the same level as the previous task, so it's better to use
this with to-do items than with projects or headings."
    (interactive)
    (org-agenda-todo "DONE")
    (org-agenda-switch-to)
    (org-capture 0 "t"))
;; Override the key definition
(define-key org-agenda-mode-map "X" 'my/org-agenda-mark-done-and-add-followup)
#+END_SRC

**** Capture something based on the agenda

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-new ()
  "Create a new note or task at the current agenda item.
Creates it at the same level as the previous task, so it's better to use
this with to-do items than with projects or headings."
  (interactive)
  (org-agenda-switch-to)
  (org-capture 0))
;; New key assignment
(define-key org-agenda-mode-map "N" 'my/org-agenda-new)
#+END_SRC

**** Sort by date and priority

#+BEGIN_SRC emacs-lisp
(setq org-agenda-sorting-strategy
      '((agenda time-up priority-down tag-up category-keep effort-up)
        ;; (todo user-defined-up todo-state-up priority-down effort-up)
        (todo todo-state-up priority-down effort-up)
        (tags user-defined-up)
        (search category-keep)))
(setq org-agenda-cmp-user-defined 'my/org-sort-agenda-items-user-defined)
(require 'cl)
(defun my/org-get-context (txt)
  "Find the context."
  (car (member-if
        (lambda (item) (string-match "@" item))
        (get-text-property 1 'tags txt))))

(defun my/org-compare-dates (a b)
  "Return 1 if A should go after B, -1 if B should go after A, or 0 if a = b."
  (cond
   ((and (= a 0) (= b 0)) nil)
   ((= a 0) 1)
   ((= b 0) -1)
   ((> a b) 1)
   ((< a b) -1)
   (t nil)))

(defun my/org-complete-cmp (a b)
  (let* ((state-a (or (get-text-property 1 'todo-state a) ""))
         (state-b (or (get-text-property 1 'todo-state b) "")))
    (or
     (if (member state-a org-done-keywords-for-agenda) 1)
     (if (member state-b org-done-keywords-for-agenda) -1))))

(defun my/org-date-cmp (a b)
  (let* ((sched-a (or (get-text-property 1 'org-scheduled a) 0))
         (sched-b (or (get-text-property 1 'org-scheduled b) 0))
         (deadline-a (or (get-text-property 1 'org-deadline a) 0))
         (deadline-b (or (get-text-property 1 'org-deadline b) 0)))
    (or
     (my/org-compare-dates
      (my/org-min-date sched-a deadline-a)
      (my/org-min-date sched-b deadline-b)))))

(defun my/org-min-date (a b)
  "Return the smaller of A or B, except for 0."
  (funcall (if (and (> a 0) (> b 0)) 'min 'max) a b))

(defun my/org-sort-agenda-items-user-defined (a b)
  ;; compare by deadline, then scheduled date; done tasks are listed at the very bottom
  (or
   (my/org-complete-cmp a b)
   (my/org-date-cmp a b)))

(defun my/org-context-cmp (a b)
  "Compare CONTEXT-A and CONTEXT-B."
  (let ((context-a (my/org-get-context a))
        (context-b (my/org-get-context b)))
    (cond
     ((null context-a) +1)
     ((null context-b) -1)
     ((string< context-a context-b) -1)
     ((string< context-b context-a) +1)
     (t nil))))

(defun my/org-sort-agenda-items-todo (a b)
  (or
   (org-cmp-time a b)
   (my/org-complete-cmp a b)
   (my/org-context-cmp a b)
   (my/org-date-cmp a b)
   (org-cmp-todo-state a b)
   (org-cmp-priority a b)
   (org-cmp-effort a b)))
#+END_SRC

**** Projects
Projects are exclusively marked with :project:
#+BEGIN_SRC emacs-lisp
(defun my/org-show-active-projects ()
  "Show my current projects."
  (interactive)
  (org-tags-view nil "project-inactive-someday"))
#+END_SRC
*** Org basics

#+BEGIN_SRC emacs-lisp

(setq org-use-fast-todo-selection t)

(setq org-treat-S-cursor-todo-selection-as-state-change nil)

(setq org-goto-interface 'outline
      org-goto-max-level 10)
(setq org-startup-folded nil)
(setq org-cycle-include-plain-lists 'integrate)

(global-set-key (kbd "C-c c") 'org-capture)
#+END_SRC

See agenda with todo lists. Custom command.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("c" "Simple agenda view"
	 ((agenda "")
	  (alltodo "")))))
#+END_SRC
*** Refile and tags

  #+BEGIN_SRC emacs-lisp
  (setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
  (setq org-refile-use-outline-path t)                  ; Show full paths for refiling

  (setq org-tag-alist '(("@work" . ?b)
			("@home" . ?h)
			("@writing" . ?w)
			("@errands" . ?e)
			("@coding" . ?c)
			("@phone" . ?p)
			("@reading" . ?r)
			("@computer" . ?l)
			("app" . ?0)
			("urgent" .?u)
			("inspiration" . ?i)))

  ;; Shortcuts
  (defvar my/refile-map (make-sparse-keymap))

  (defmacro my/defshortcut (key file)
    `(progn
       (set-register ,key (cons 'file ,file))
       (define-key my/refile-map
	 (char-to-string ,key)
	 (lambda (prefix)
           (interactive "p")
           (let ((org-refile-targets '(((,file) :maxlevel . 6)))
		 (current-prefix-arg (or current-prefix-arg '(4))))
             (call-interactively 'org-refile))))))


  (define-key my/refile-map "," 'my/org-refile-to-previous-in-file)

  (my/defshortcut ?o "~/personal/organizer.org")
  #+END_SRC

  ;; TODO : add daily work checklist
  ;; TODO : show daily dashboard of checklist and items to do
  ;; TODO : shortcut for work
  ;; TODO : Habit checklist
  ;; TODO : Add daily news checklist
  ;; TODO : Add daily reading checklist
** Terminal
*** Fish
#+BEGIN_SRC emacs-lisp
(setq multi-term-program "/usr/local/bin/fish -l")

(when (require 'multi-term nil t)
  (global-set-key (kbd "<s-return>") 'multi-term)
  (setq multi-term-buffer-name "term"
        multi-term-program "/usr/local/bin/fish"))
#+END_SRC
** Self tracking
*** Quantified
#+BEGIN_SRC emacs-lisp
(defmacro my/org-with-current-task (&rest body)
  "Execute BODY with the point at the subtree of the current task."
  `(if (derived-mode-p 'org-agenda-mode)
       (save-window-excursion
         (org-agenda-switch-to)
         ,@body)
     ,@body))

(defun my/org-clock-in-and-track ()
  "Start the clock running. Clock into Quantified Awesome."
  (interactive)
  (my/org-with-current-task
   (org-clock-in)
   (call-interactively 'my/org-quantified-track)
   (when (org-entry-get (point) "AUTO")
     (org-open-link-from-string (org-entry-get (point) "AUTO")))))
(bind-key "!" 'my/org-clock-in-and-track org-agenda-mode-map)

(defmacro my/with-org-task (&rest body)
  "Run BODY within the current agenda task, clocked task, or cursor task."
  `(cond
    ((derived-mode-p 'org-agenda-mode)
     (let* ((marker (org-get-at-bol 'org-marker))
            (buffer (marker-buffer marker))
            (pos (marker-position marker)))
       (with-current-buffer buffer
         (save-excursion
           (save-restriction
             (widen)
             (goto-char pos)
             ,@body)))))
    ((and (derived-mode-p 'org-mode) (org-at-heading-p)) (save-excursion ,@body))
    ((org-clocking-p) (save-excursion (org-clock-goto) ,@body))
    ((derived-mode-p 'org-mode) ,@body)))

(defun my/org-quantified-track (&optional category note)
  "Create a tracking record using CATEGORY and NOTE.
Default to the current task in the agenda, the currently-clocked
entry, or the current subtree in Org."
  (interactive (list nil nil))
  (unless (and category note)
    (my/with-org-task
     (setq category (or category
                        (org-entry-get-with-inheritance "QUANTIFIED")))
     (cond
      ((null category)
       (setq category (read-string "Category: "))
       (org-set-property "QUANTIFIED" category))
      ((string= category "ask")
       (setq category (read-string "Category: "))))
     (setq note
           (concat
            (if (string= (or (org-entry-get-with-inheritance "QUANTIFIEDQUIET") "") "t")
                "!private "
              "")
            (or note (elt (org-heading-components) 4) (read-string "Note: "))))))
  (quantified-track (concat category " | " note)))

  (defun my/org-quick-clock-in-task (location jump)
    "Track and clock in on the specified task.
  If JUMP is non-nil or the function is called with the prefix argument, jump to that location afterwards."
    (interactive (list (save-excursion (my/org-refile-get-location "Location")) current-prefix-arg))
    (when location
      (if jump
          (progn (org-refile 4 nil location) (my/org-clock-in-and-track))
        (save-window-excursion
          (org-refile 4 nil location)
          (my/org-clock-in-and-track)))))
  (bind-key "C-c q" 'my/org-quick-clock-in-task)

(require 'quantified nil t)
#+END_SRC
*** Weekly review
*** Weekly planning
** Media
*** Music
** Weather

#+begin_src emacs-lisp
  (use-package yahoo-weather
    :config
    (yahoo-weather-mode t))
#+end_src
